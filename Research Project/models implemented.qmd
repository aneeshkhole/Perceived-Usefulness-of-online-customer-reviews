# Models Implemented {#sec-models-implemented}

```{python importsBlock}
import pandas as pd, numpy as np, matplotlib.pyplot as plt
import seaborn as sns
# from sklearn import tree
from sklearn.metrics import (
    accuracy_score,f1_score,
    precision_score,recall_score, 
    confusion_matrix, ConfusionMatrixDisplay,
)
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.neighbors import KNeighborsClassifier
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from sklearn import svm
from imblearn.over_sampling import ADASYN, SMOTE
import random
from sklearn.utils.class_weight import compute_class_weight

import statsmodels.api as sm

```

```{python DataImports}
product_data = pd.read_csv('../data/master_product_list.csv')
review_orig = pd.read_csv('../data/reviews_with_stats.csv')
reviews = pd.read_csv('../data/reviews_outlier_adjusted.csv')
reviews['prodSiteID'] = reviews['prodSiteID'].str.upper()
review_orig['prodSiteID'] = reviews['prodSiteID'].str.upper()
product_data['prodSiteID'] = product_data['prodSiteID'].str.upper()

reviews = reviews.merge(
    right=pd.DataFrame(
      product_data[
        [
            'product_price','prodSiteID',
            'prod_subjectivity','total_star_rating','site'
        ]
      ]
    ),
    on='prodSiteID',
    how='left'
)

review_orig = review_orig.merge(
    right=pd.DataFrame(
      product_data[
        [
            'product_price','prodSiteID',
            'prod_subjectivity','total_star_rating','site'
        ]
      ]
    ),
    on='prodSiteID',
    how='left'
)

reviews['is_helpful'] = np.select(
    [
        reviews['review_helpful_votes'] > 0,
        (reviews['review_helpful_votes'] == 0) | (reviews['review_helpful_votes'].isna()),
    ],
    [
        1,
        0
    ]
)

review_orig['is_helpful'] = np.select(
    [
        review_orig['review_helpful_votes'] > 0,
        (review_orig['review_helpful_votes'] == 0 )| (reviews['review_helpful_votes'].isna()),
    ],
    [
        1,
        0
    ]
)

reviews['site'] = np.select(
    [
        reviews['site_y'].str.lower() == 'amazon',
        reviews['site_y'].str.lower() == 'target',
        reviews['site_y'].str.lower() == 'bestbuy'
    ],
    [
        1/3,2/3,1
    ]
)

review_orig['site'] = np.select(
    [
        review_orig['site_y'].str.lower() == 'amazon',
        review_orig['site_y'].str.lower() == 'target',
        review_orig['site_y'].str.lower() == 'bestbuy'
    ],
    [
        1/3,2/3,1
    ]
)

test_metrics = pd.DataFrame(
    {
        'Model':[],
        #'Useful Level':[],
        'Accuracy':[],
        'F1':[],
        'Precision':[],
        'Recall':[]
    }
)

reviews = reviews.dropna(subset=[
    'review_star_rating_adjusted', 'review_helpful_votes_adjusted',
    'review_subjectivity_adjusted', 'review_polarity_adjusted',
    'review_length_adjusted','prod_subjectivity','total_star_rating','site'
],axis=0)
review_orig = review_orig.dropna(subset=[
    'review_star_rating', 'review_helpful_votes',
    'review_subjectivity', 'review_polarity',
    'review_length','prod_subjectivity','total_star_rating','site'
],axis=0)

# tmp = pd.DataFrame(
#     reviews[reviews['productID'].isin(list(range(1,16)))]
# )

tmp = reviews[reviews['productID'].isin(list(range(1,16)))].copy()

train_frame = pd.DataFrame(
    tmp.sample(n=int(.8*len(tmp)),random_state=1337)
)

test_frame = pd.DataFrame(
    tmp.loc[~tmp.index.isin(train_frame.index)]
)

additional_data = review_orig[~review_orig['prodSiteID'].isin(train_frame['prodSiteID'].unique())]

test_frame = pd.concat([test_frame, additional_data], ignore_index=True)

test_frame = test_frame.sample(n=int(.2*len(tmp)),random_state=1337)

# test_frame = pd.DataFrame(
#     review_orig[~review_orig['prodSiteID'].isin(train_frame['prodSiteID'].unique())]
# )
```

```{python test}

# print(test_frame.shape)
# print(train_frame.shape)
```

```{python DataTransforms}
X_train,X_test,y_train,y_test= [
    StandardScaler().fit_transform(np.array(train_frame[[
        'review_star_rating_adjusted', #'review_helpful_votes_adjusted',
        'review_subjectivity_adjusted', 'review_polarity_adjusted',
        'review_length_adjusted','prod_subjectivity','total_star_rating','site'
    ]])),
    StandardScaler().fit_transform(np.array(test_frame[[
        'review_star_rating', #'review_helpful_votes',
        'review_subjectivity', 'review_polarity',
        'review_length','prod_subjectivity','total_star_rating','site'
    ]])),
    np.array(train_frame['is_helpful']),
    np.array(test_frame['is_helpful'])
]
```


```{python PCATransforms}
pca = PCA()
pcs = pca.fit_transform(X_train)
pr_df = pd.DataFrame(data=pcs)
pr_df.columns = ["PC{}".format(i) for i in range(1,len(pca.components_)+1)]
exp_var = pca.explained_variance_ratio_
cum_var = np.cumsum(exp_var)
cum_var_df = pd.DataFrame({
    'Principal Component':[f'PC{i+1}' for i in range(len(cum_var))],
    'Cumulative Variance':cum_var,
    'Explained Variance':exp_var
})
#display(cum_var_df)
pca = PCA(n_components=6)
w=pca.fit(X_train)
X_train_pca=pca.transform(X_train)
X_test_pca=pca.transform(X_test)
```

In our modeling of the collected data, we seek to investigate several models for the generalization of the work performed by @percUse.

We will examine, compare, and contrast the use of the following models: 

* Multiple Linear Regression Prediction

* Logistic Regression Classification

* K-Nearest Neighbors Classification

* Support Vector Machine Classification

## Included Variables

```{python tbl-var-selection}
#| label: tbl-var-selection
#| tbl-cap: Selected Variables for Model Training

pd.DataFrame({
    'Variable':['review_star_rating', #'review_helpful_votes',
        'review_subjectivity', 'review_polarity',
        'review_length','prod_subjectivity','total_star_rating', 'site', 'review_helpful_votes'],
    'Pre-Transformation Type':['int','float','float','int','float','float','dummy float','int'], #'int',
    'Post-Transformation Type':['PCA scaled float','PCA scaled float','PCA scaled float','PCA scaled float','PCA scaled float','PCA scaled float','PCA scaled float','PCA scaled float'],
    'Purpose':['feature','feature','feature','feature','feature','feature','feature','response'],
    'Reason for Inclusion':['literature survey','literature survey','literature survey','literature survey','intuition','literature survey', 'intuition from EDA','literature survey']
}).style.hide(axis='index')
```

## Data Adjustments

As noted in our exploratory data analysis, each individual site has statistically significant differences in key variables we're considering in our modeling.  To mitigate the potential for under or overfitting, and misrepresentation due to variable scale we perform the following transformations to our data:

<!--NOTE - need information here on specific variables under consideration for our modeling-->

1. Variable outlier adjustment.  We noted in our EDA that each of the e-commerce platforms had high volumes of outliers with respect to the inter-quartile range.  We applied a transformation to our data to map any outlier variable value on a per-website basis from its value to $\mu+3\cdot sd(\text{variable})$ for high-end outliers, and $\mu-3\cdot sd(\text{variable})$ for low-end outliers.  In the event that either of these values exceeded the minimum or maximum value of the dataset, we mapped the value to the minimum or maximum accordingly.

2. Standard scaling of variables.  After adjusting outliers, we re-mapped all of our feature variables to be on the scale of the standard normal distribution $N\sim(0,1)$

3. Response variable transformation to binary value.  We denoted a single useful vote as meaning that the review was useful to customers, and mapped the value to True/1, and False/0 otherwise.

Here is a sample (first 10 observations) of our data prior to the transformation:

```{python tbl-pre-xform-data}
#| label: tbl-pre-xform-data
#| tbl-cap: Data (pre-transformation)

#Let's look at this from the perspective of
#key variables we're exploring...
train_frame[['review_star_rating', 
        'review_subjectivity', 
        'review_polarity',
        'review_length',
        'prod_subjectivity',
        'total_star_rating','site']].head(10).style.hide(axis='index')
```

And here is a sample of our data after the applied transformations:

* Snippet of first 10 observations in our training dataset, post-transformation:

```{python tbl-post-xform-data}
#| label: tbl-post-xform-data
#| tbl-cap: Data (post-transformation)

pd.DataFrame(X_train, columns=[
    'review_star_rating', #'review_helpful_votes',
    'review_subjectivity', 
    'review_polarity',
    'review_length',
    'prod_subjectivity',
    'total_star_rating','site']).head(10).style.hide(axis='index')


```

Classes in the response variable (the number of helpful votes a review received) set were mapped as follows for all non-linear models:

* 0: if the review had no helful votes

* 1: if the review had one or more than 1 helpful votes

Our reasoning for this transformation is that, across the totality of our data, a comment receiving more than one vote as being useful is quite rare in our dataset, as uncovered during our exploratory data analysis.  As such, even a single vote for being useful should put the comment in the running for being considered useful. 

### Dimensionality Reduction

For all models outside of the multiple linear regression, we performed a principal component analysis on the scaled data.  

```{python tbl-PCA-Info}
#| label: tbl-PCA-Info
#| tbl-cap: Cumulative Variance of Principal Components (selected features)
display(cum_var_df.style.hide(axis='index'))
```

To reduce dimensionality for Logistic Regression, Support Vector Machine, and K-Nearest Neighbor models, we elected to reduce from 7 principal commponents to 6.  From the above table, we see that these 6 components explain approximately 95% of the variation within the training data.  We projected our training and testing data from their 7-dimensional feature space to a reduced 6-dimensional principal component vector space and simplify computations.  The only exception here is for our multiple linear regression, which used all 7 dimensions in its perscribed vector space.

### Training Data

To train our dataset, we leveraged the data, post-transformation to train each of our models, including the adjustments of outlier datapoints to being within 3 standard deviations of the mean of each variable.  We selected an 80% sample of this data and leveraged the same dataset to train each model.

In the interest of generalization, we sought to take our training dataset solely from products that were common across all three e-commerce platforms.  By working with common data from each site, the data and the models may be able to formulate a more generalized construct of how certain variables behave within the different contexts of each platforms, and assist in better prediction and classification of comments as being useful or not.

### Testing Data

For testing, we evaluated each model against transformed data, omitting the transformation of any outliers to being within 3 standard deviations of the mean.  We performed this action to enable a fair comparison of each model against one another when working with real-world data.

### Desired Outcomes and Objectives

Predictive modeling for the usefulness of a user comment on a product, in and of itself, cannot be conducted 100% objectively.  We are interested in the exploration of misclassifications - particularly of false positives.  

Our data exploration revealed that having even a single vote for a comment as being useful was exceedingly rare, with a median and mean number of votes hovering at or about 0 regardless of the website on which the comment was posted.

Additionally, from a technological perspective, the ability of a web user interface programmer or designer to simply filter or arrange comments by the number of votes they received is trivial.

With the above considerations in mind, we are interested in a model that provides reasonable accuracy while also having an apprpriate amount of recall and a reasonable F1 score.  Having a model that perfectly maps predictions to actual outcomes is not useful to this research.  Having a number of classified false positives for exploration and subjective evaluation is what interests us.

When exploring test results, we seek a percent of total positive predictions (true and false positives) matching that of the testing dataset.  With this in mind, we won't have the best accuracy, F1, precision, or recall.  Having values for precision and recall hovering around 0.5 should support us in classifying reviews that have no votes as being useful as potentially being useful.

## Examination of the Original Multiple Linear Regression

### Linear Model Construction

We leveraged a similar formulation to that which was used within the research of @percUse.

Our version of the linear model is designed as follows:
$\hat{y} = \beta_0+\beta_1X_{rsr}+\beta_2X_{rs}+\beta_3X_{rp}+\beta_4X_{rl}+\beta_5X_{ps}$ $+\beta_6X_{tsr}+\beta_7X_{s}$

Where each of the following variables have been standard-scaled to a range between 0 and 1 for the input data:

* $X_{rsr}$ corresponds to the individual review's star rating

* $X_{rs}$ corresponds to the review's subjectivity score

* $X_{rp}$ corresponds to the review's polarity score

* $X_{rl}$ corresponds to the review's length (in words)

* $X_{ps}$ corresponds to the product description subjectivity score 

* $X_{tsr}$ is the overall star rating for the product.

* $X_{s}$ is the site on which the comment was found (converted to a dummy variable for each website).

We leveraged $X_{ps}$ as a proxy for the previous model's binary attribute for whether or not a good was search-based or experienced based.  @percUse leveraged a set of binary variables to classify a good as being search, experience, or mixed products.  Our intuition was that, given the subjectivity of a product's description and/or specifications, a higher subjectivity score would correspond to an experience-based good, a lower subjectivity would correspond to a search-based good, and everything in-between would be a mixed product.  This construction allows for any product to have a continuous potential range, and for most products to be mixed products (some tending more toward experience or search).

<!-- 
The methods of @percUse leveraged a binary class feature to denote whether a product was a search good, an experience good, or a mixed good.  Our exploration leveraged a continuous scale variable from 0 to 1, being the subjectivity of the product description and specifications.  Our intent was to examine whether their model could be simplified using this single continuous variable.  In theory, a product within an e-commerce platform could be considered a search good if it has more specificity (thus less subjectivity), and an experience good if it has greater subjectivity, and any product could lie anywhere within that spectrum of being a degree of search and a degree of experience. 
-->

### Inspection of Linear Model Assumptions

Generally, our examination of the multiple linear regression performed by @percUse failed to meet the assumptions of linear regression (normality of residuals, linear pattern in fitted vs. observed values, and constant variance of residuals). 

#### Linearity of the Model

Our model failed to achieve any clear form of linearity between fitted and observed values.

```{python fig-mlr-results}
#| label: fig-mlr-results
#| fig-cap: Linear Relationship Between Predictors and Response

##train - test

y_train_mlr,y_test_mlr = [np.array(train_frame['review_helpful_votes']),
    np.array(test_frame['review_helpful_votes'])]

from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score
#from sklearn.linear_model import LassoLarsIC

mlr = LinearRegression()

mlr.fit(X_train,y_train_mlr)

y_hat_base = mlr.predict(X_test)

beta_base = mlr.coef_
beta0_base = mlr.intercept_
R2_base = r2_score(y_test_mlr,y_hat_base)
MSPE_base = np.mean((y_hat_base - y_test_mlr)**2)


plt.title('Multiple Linear Regression')
plt.xlabel('Predicted Values')
plt.ylabel('Observed Values')
plt.scatter(
    y_hat_base,y_test_mlr    
)
plt.show()
n,p = X_train.shape
aR2 = 1-(1-R2_base) * ((n-1)/(n-p))
#display(R2_base,aR2)
```

The fitted vs. observed values for this plot are not indicative of a linear pattern between the feature and response variables.  It provides a high mean square prediction error of `{python} round(MSPE_base,4)`, an $R^2$ of `{python} round(R2_base,4)` and adjusted $R^2$ value of `{python} round(aR2,4)`.  The lack of even a moderate correlation here suggests one of the following:

* The wider spread of data from multiple websites and wider range of products reduced the correlation found by @percUse

* The linear model is not generalizable.

* The model is no better than randomly guessing the number of votes a comment could or should have associated with it.

What about if we filter down the testing data solely to reflect the positive cases - where the review comment has at least 1 vote for being useful?

```{python fig-mlr-useful-only}
#| label: fig-mlr-useful-only
#| fig-cap: Relationship Between Predictors and Response (Reviews with at least 1 useful vote)

mlr_data_new = pd.DataFrame(X_test, columns=[
    'review_star_rating', #'review_helpful_votes',
    'review_subjectivity', 
    'review_polarity',
    'review_length',
    'prod_subjectivity',
    'total_star_rating','site'])
mlr_data_new['is_helpful'] = y_test_mlr

mlr_data_new = pd.DataFrame(mlr_data_new[mlr_data_new['is_helpful']>0])

mlr_X, mlr_y = [
    mlr_data_new[[
        'review_star_rating', #'review_helpful_votes',
        'review_subjectivity', 
        'review_polarity',
        'review_length',
        'prod_subjectivity',
        'total_star_rating','site'
    ]],
    mlr_data_new['is_helpful']
]

y_hat_new = mlr.predict(mlr_X)

plt.title('Multiple Linear Regression (Reviews Voted Useful Only)')
plt.xlabel('Predicted Values')
plt.ylabel('Observed Values')
plt.scatter(
    y_hat_new,mlr_y  
)
plt.show()

```

The linearity issue remains even in this case.

<!--Our testing produced the following coefficients:

$\beta_0$: `{python} round(mlr.intercept_,3)`, $\beta_1$: `{python} round(mlr.coef_[0],3)`,$\beta_2$: `{python} round(mlr.coef_[1],3)`,$\beta_3$: `{python} round(mlr.coef_[2],3)`,$\beta_4$: `{python} round(mlr.coef_[3],3)`,$\beta_5$: `{python} round(mlr.coef_[4],3)`,$\beta_6$: `{python} round(mlr.coef_[5],3)`

On new training data, the model appears to underpredict the output value, across the board, for the new data.  That being said, there is still a strong linear trend between the predictors and the response.  The intent of this model is not to predict the actual number of votes that a review might have, but whether or not that review would be considered useful to customers.  

Generally examining this result, we would conclude that there is a linear trend between these features, their coefficients, and their corresponding response.-->

#### Homoscedasticity on Normalized Data

This model has substantial challenges with heteroscedasticity.  Let's examine a plot of fitted vs. residuals in the model:

```{python fig-non-constant-var-1}
#| label: fig-non-constant-var-1
#| fig-cap: Heteroscedasticity in Model

plt.scatter(
    y_hat_base,y_hat_base - y_test_mlr
)
plt.xlabel('Predicted Value')
plt.ylabel('Model Residuals')
plt.title('Evaluating Constant Variance - Predicted vs. Residual Values')
plt.show()
```

As expected for a model that does not have a clear linear pattern, the residuals for this linear model are heteroscedastic.  We should expect to see a constant variance in a plot of predicted vs. residual values, with no correlation between the errors and the predictions.  Here, we witness this issue directly, lending to the idea that the model is a poor fit for the data, and the nature of the model (e.g. additional data, additional features, or other feature/response transformations) would need to change substantially to produce effective predictive results.

#### Normality in Residuals
```{python fig-qq-resid}
#| label: fig-qq-resid
#| fig-cap: Model Residuals are Abnormal

x_points = y_hat_base
fig,ax = plt.subplots()
mu = x_points.mean()
sd = x_points.std()
norm = (x_points-mu) / sd
sm.qqplot(norm,ax=ax)
ax.axline((0,0),slope=1,color='black')
fig.suptitle('Q-Q Plot of Residuals')
plt.show()
```

From the above plot, it is clear that this model fails to adhere to the multiple linear regression requirement for residual normality.

#### Conclusion on MLR model

Expanding the Multiple Linear Regression beyond the scope of the study performed by @percUse seems to fail all of the assumptions of a linear model.<!--, and does not appear to produce a tracable predictive pattern that may support classification of a review comment as being useful or not to prospective customers.-->

Irrespective of this finding, we will output the results of this model sorted in descending order of the score provided by the model, to compare and contrast with the findings of other models.  A simple examination of the MLR with respect to its linearity may not be an effective means to evaluate this model's performance.

Examining instead how the model predicts usefulness in comparison to other methods, alongside a subjective evaluation of the comments themselves may offer greater insight to its performance.

```{python UsefulComments-mlr}
test_frame['product'] = test_frame.apply(lambda row:product_data[product_data['prodSiteID']==row['prodSiteID']]['product_title'].iloc[0],axis=1)
test_frame['pred_useful'] = y_hat_base
dat = test_frame[test_frame['is_helpful']==0].sort_values(by='pred_useful',ascending=False)[['site_y','product','product_price','review_header','reviewer_name','review_content','review_star_rating','review_helpful_votes','review_polarity','review_subjectivity','review_length','total_star_rating','prod_subjectivity','pred_useful']].copy().reset_index()

#add a rank column for comparision
dat['rank'] = list(range(1,len(dat)+1))


dat.to_csv('../data/MLRPredUseful.csv')
```

## Logistic Regression Classification

Given the aforementioned challenges with the linear model, our next choice for examination was logistic regression.  The MLR called for use of only numeric or continuous variables.  Logisitic regression enables us to examine the inclusion of additional categorical variables as part of the regression consideration.

### Hyperparameter Tuning

Logistic regression is, by our assessment, among the best performing models in our research effort. We inspected 3 logistic regression models - one tuned using the class weight hyperparameter to address the class imbalance present in the dataset. By assigning a higher weight to the minority class (1, or at least 1 vote for being useful) and a lower weight to the majority class (0, or no votes for the comment as being useful), the model was able to better capture the patterns associated with the minority class, leading to metrics in our target range.

### Oversampling techniques

Additionally, 2 more logistic regression models are trained using two oversampling techniques, namely ADASYN and SMOTE. ADASYN, which generates synthetic samples for the minority class based on their difficulty in learning regions, and SMOTE, which creates synthetic samples by interpolating between existing minority class samples, were used to address the class imbalance problem. These techniques help to provide the model with more balanced training data, allowing it to learn the characteristics of both classes more effectively.
 
It is a well know fact that oversampling techniques can be employed in the event of a severe class imbalance if hyperparameter tuning does not improve the model performance. However, despite the heavy class imbalance, the tuned model and the SMOTE model achieve great result with approximately 80% accuracy indicating that it is proficient at making correct predictions. However, the models do differ in their scoring for precision and recall.  

The tuned model delivers a higher precision and a lower recall, bouth around our target range of 0.4 to 0.55 for both, leaning us in the direction of examining the tuned model's outputs for predicted useful comments.  The "incorrect" prediction of elements from the minority class, which is what we're looking for.  We don't want an over-prediction for false positives, but a reasonable degree of comments that could potentially be useful from a customer standpoint.

### Logistic Regression Test Results

```{python tbl-log-reg-results}
#| label: tbl-log-reg-results
#| tbl-cap: Test Scores for Logistic Regression

# need to divide into pieces to add figures / labels for each.
#Logmod hyperparameter
random.seed(123)

LogMod = LogisticRegression(class_weight={0:.1,1:.9})
LogMod.fit(X_train_pca,y_train)
y_pred = LogMod.predict(X_test_pca)
#y_pred = (LogMod.predict_proba(X_test_pca)[:,1]>0.25)

test_metrics.loc[len(test_metrics)] = {
    'Model':'Logistic Regression (TUNED)',
    #'Useful Level': "above 0",
    'Accuracy':accuracy_score(y_test,y_pred),
    'F1':f1_score(y_test,y_pred),
    'Precision':precision_score(y_test,y_pred),
    'Recall':recall_score(y_test,y_pred)
}
# ConfusionMatrixDisplay(confusion_matrix(y_test,y_pred)).plot()
# display(test_metrics)

#### Logmod ADASYN

adasyn = ADASYN()
X_train_adasyn, y_train_adasyn = adasyn.fit_resample(X_train_pca, y_train)
logmod_adasyn = LogisticRegression()
logmod_adasyn.fit(X_train_adasyn, y_train_adasyn)
y_pred_adasyn = logmod_adasyn.predict(X_test_pca)


test_metrics.loc[len(test_metrics)] = {
    'Model': 'Logistic Regression (ADASYN)',
    #'Useful Level': "above 0",
    'Accuracy': accuracy_score(y_test, y_pred_adasyn),
    'F1': f1_score(y_test, y_pred_adasyn),
    'Precision': precision_score(y_test, y_pred_adasyn),
    'Recall': recall_score(y_test, y_pred_adasyn)
}

# ConfusionMatrixDisplay(confusion_matrix(y_test, y_pred_adasyn)).plot()
# display(test_metrics)

X_test_scaled = StandardScaler().fit_transform(X_test)
X_test_pca = pca.transform(X_test_scaled)

#### Logmod SMOTE

smote = SMOTE()
X_train_smote, y_train_smote = smote.fit_resample(X_train_pca, y_train)
logmod_smote = LogisticRegression()
logmod_smote.fit(X_train_smote, y_train_smote)

y_pred_smote = logmod_smote.predict(X_test_pca)

test_metrics.loc[len(test_metrics)] = {
    'Model': 'Logistic Regression (SMOTE)',
    #'Useful Level': "above 0",
    'Accuracy': accuracy_score(y_test, y_pred_smote),
    'F1': f1_score(y_test, y_pred_smote),
    'Precision': precision_score(y_test, y_pred_smote),
    'Recall': recall_score(y_test, y_pred_smote)
}


# ConfusionMatrixDisplay(confusion_matrix(y_test, y_pred_smote)).plot()
# display(test_metrics)

# test_metrics_df = pd.DataFrame(test_metrics)
# display(test_metrics_df[:3].style.hide(axis='index'))

display(
    test_metrics[test_metrics['Model'].str.contains('Logistic')].style.hide(axis='index')
)

```

```{python fig-cm-logreg}
#| label: fig-cm-logreg
#| fig-cap: Logistic Regression Confusion Matrices
#| fig-align: center

fig, axes = plt.subplots(3, 1, figsize=(18, 6))

ConfusionMatrixDisplay(confusion_matrix(y_test,y_pred)).plot(ax=axes[0])
axes[0].set_title('Tuned Model')

ConfusionMatrixDisplay(confusion_matrix(y_test, y_pred_adasyn)).plot(ax=axes[1])
axes[1].set_title('ADASYN')

ConfusionMatrixDisplay(confusion_matrix(y_test, y_pred_smote)).plot(ax=axes[2])
axes[2].set_title('SMOTE')

plt.tight_layout()
plt.show()
```

<!--Let's examine some of its outputs.  We'll predict the probability that the comment belongs to the "useful" class and sort in descending order, then filter out any comments that are flagged as not useful.  This may introduce to us new comments that are useful to prospective buyers.-->

```{python UsefulComments-logreg}
# review_orig['pred_useful'] = y_pred_adasyn
# x = list(review_orig[(review_orig['is_helpful']==0) &(review_orig['pred_useful']==1)]['review_content'])#[['reviewer_name','verified_purchase','review_content','review_star_rating']]
# for i in x:
#     print(i)
#print(len(x))
test_frame['pred_useful'] = LogMod.predict_proba(X_test_pca)[:,1]

dat = test_frame[test_frame['is_helpful']==0].sort_values(by='pred_useful',ascending=False)[['site_y','product','product_price','review_header','reviewer_name','review_content','review_star_rating','review_helpful_votes','review_polarity','review_subjectivity','pred_useful']].copy().reset_index()

dat['rank'] = list(range(1,len(dat)+1))

dat.to_csv('../data/LogisticRegressionPredUseful.csv')
# for i,row in dat.iterrows():
#     print(
#         "Review #{} ({})\n{}\n".format(i+1,row['product'],row['review_content'])
#     )
    #print("Review #{}:\n{}".format(i,dat[i]))
# for comment in dat:
#     print(comment+"\n")

```

<!-- These comments, holding high probability from the Logistic Regression-Tuned model, seem to have the following qualities:

* Longer comments with descriptive detail

* ...

Subjectively, if our research team were prospective buyers of these products, we find that these comments would be beneficial to us in pursuing a decision as to whether or not to purchase the product. -->

Comments, sorted by probabability of being useful in descending order, are located here (link).

## K-Nearest Neighbors Classification

K-Nearest Neighbors is used to learn and identify the target class instances. It makes predictions by calculating distance (usually, Euclidean distance) between a given instance and all other instances in the dataset in feature space. 

### Hyperparameter Tuning

The value of k is the most critial hyperparameter in the KNN Calssification algorithm. It determines the performance of the model. Usually a small k value leads to overly complex understanding of the data that might result into overfitting, however, a higher k values can lead to underfitting. 

We have looked at multiple values of k for our given data and compared a set of model metrics - accuracy, F1 score, precision, and recall to find the most optimal model to be the model with `k = 3`.

As we did for our logisitc regression models, we leveraged the SMOTE oversampling technique to support each KNN model in better predicting true positive cases.  Having additional co-located true-positive neighbors will impact the distance metric of test data points and the number of closest neighbors in a particular class.

<!--1. Just by looking at the accuracy for any given value of k, it ranges between 98-99% indicating that KNN might be a good model for the given data.

2. Among the evaluated models, KNN with `k = 3` achieves the highest F1 score of approximately 78.2%, indicating a balanced trade-off between precision and recall.

3. While all models have high precision and recall rates, KNN with higher k values (5, 7, and 9) demonstrate slightly lower F1 scores.-->

### KNN Test Results

Looking the results shown below we can say that:

1. KNN at each neighbor level performs poorer in comparison to logistic regression.  The accuracy and precision do not reach sufficient levels.  Furthermore, the total percent prediction of positive cases (ranging from 21.5-25.6%) far exceed the percent of true positive cases in the testing dataset (approximately 17%).  These over-optimistic prediction levels (in combination with a high number of false negatives) suggest we may not be meeting the mark with this model, as once again, votes for a comment as being useful is relatively rare in this dataset.

2. For KNN with n=3 neighbors, we are the closest to the actual percent of positives in the source dataset.  This model, however, has poor performance for precision, recall, and F1.

3. For KNN with n=9 neighbors, we improve the F1 score, but the precision and recall remain substantially low.

4. KNN, for any number of neighbors and given our selected features, may be an insufficient model for our use case.  All of the KNN models far exceed our target % of total positive predictions.  The source testing data has around 17% of the reviews as being "useful", whereas each of these models' positive predictions exceed that rate by at least 4%.

<!--try to tweak and tune this model for better performance--> 
```{python tbl-knn-test-results}
#| label: tbl-knn-test-results
#| tbl-cap: Test Scores for K-Nearest Neighbors

# 3 Neighbors is best performing
# need to divide this into pieces to add figure labels.
random.seed(123)

knn = KNeighborsClassifier(n_neighbors=3)

knn.fit(X_train_smote,y_train_smote)
#knn.fit(X_train_pca,y_train)
y_pred_3 = knn.predict(X_test_pca)

test_metrics.loc[len(test_metrics)] = {
    'Model':'KNN (k=3)',
    #'Useful Level':"above 0",
    'Accuracy':accuracy_score(y_test,y_pred_3),
    'F1':f1_score(y_test,y_pred_3),
    'Precision':precision_score(y_test,y_pred_3),
    'Recall':recall_score(y_test,y_pred_3)
}

# 5 Neighbors
knn = KNeighborsClassifier(n_neighbors=5)
knn.fit(X_train_smote,y_train_smote)
#knn.fit(X_train_pca,y_train)
y_pred_5 = knn.predict(X_test_pca)
test_metrics.loc[len(test_metrics)] = {
    'Model':'KNN (k=5)',
    #'Useful Level':"above 0",
    'Accuracy':accuracy_score(y_test,y_pred_5),
    'F1':f1_score(y_test,y_pred_5),
    'Precision':precision_score(y_test,y_pred_5),
    'Recall':recall_score(y_test,y_pred_5)
}

# 7 Neighbors
knn = KNeighborsClassifier(n_neighbors=7)
knn.fit(X_train_smote,y_train_smote)
#knn.fit(X_train_pca,y_train)
y_pred_7 = knn.predict(X_test_pca)
test_metrics.loc[len(test_metrics)] = {
    'Model':'KNN (k=7)',
    #'Useful Level':"above 0",
    'Accuracy':accuracy_score(y_test,y_pred_7),
    'F1':f1_score(y_test,y_pred_7),
    'Precision':precision_score(y_test,y_pred_7),
    'Recall':recall_score(y_test,y_pred_7)
}

# 9 Neighbors
knn = KNeighborsClassifier(n_neighbors=9)
knn.fit(X_train_smote,y_train_smote)
#knn.fit(X_train_pca,y_train)
y_pred_9 = knn.predict(X_test_pca)
test_metrics.loc[len(test_metrics)] = {
    'Model':'KNN (k=9)',
    #'Useful Level':"above 0",
    'Accuracy':accuracy_score(y_test,y_pred_9),
    'F1':f1_score(y_test,y_pred_9),
    'Precision':precision_score(y_test,y_pred_9),
    'Recall':recall_score(y_test,y_pred_9)
}

# Display results
# test_metrics_df = pd.DataFrame(test_metrics)
# display(test_metrics_df[3:7].style.hide(axis='index'))
display(
    test_metrics[test_metrics['Model'].str.contains('KNN')].style.hide(axis='index')
)

```

```{python fig-cm-knn}
#| label: fig-cm-knn
#| fig-cap: Confusion Matrices for KNN Models
#| fig-align: center

fig, axes = plt.subplots(4, 1, figsize=(11, 10))

ConfusionMatrixDisplay(confusion_matrix(y_test,y_pred_3)).plot(ax=axes[0])
axes[0].set_title('KNN Model (k=3)')

ConfusionMatrixDisplay(confusion_matrix(y_test, y_pred_5)).plot(ax=axes[1])
axes[1].set_title('KNN Model (k=5)')

ConfusionMatrixDisplay(confusion_matrix(y_test, y_pred_7)).plot(ax=axes[2])
axes[2].set_title('KNN Model (k=7)')

ConfusionMatrixDisplay(confusion_matrix(y_test, y_pred_9)).plot(ax=axes[3])
axes[3].set_title('KNN Model (k=9)')

plt.tight_layout()
plt.show()
```

Simply examining the above confusion matrices, especially the upper-right hand corner false posistives, we see that KNN is likely over-optimistic about the usefulness of customer feedback.  For the purpose of comparison to other models, we will examine the results of KNN `n=3`, as it held the closest value to the overall percent of true positives (17% true positives, 21.4% predicted).

```{python UsefulComments-knn}
test_frame['pred_useful'] = y_pred_3
dat = test_frame[test_frame['is_helpful']==0].sort_values(by='pred_useful',ascending=False)[['site_y','product','product_price','review_header','reviewer_name','review_content','review_star_rating','review_helpful_votes','review_polarity','review_subjectivity','review_length','total_star_rating','prod_subjectivity','pred_useful']].copy().reset_index()

dat['rank'] = list(range(1,len(dat)+1))

# for i,row in dat.iterrows():
#     print(
#         "Review #{} ({})\n{}\n".format(i+1,row['product'],row['review_content'])
#     )

dat.to_csv('../data/KNNPredUseful.csv')
```

## Support Vector Machine Classification

Support Vector Machines work on classification problems by finding an optimal hyperplane that best classifies the target classes in the given feature space. Because of its flexibility of moving the hyperplane and adapting to the intricacies of the data, SVM could be a useful and powerful algorithm for our use case.

### Hyperparameter Tuning

The complexity of a SVM model is determined by the choice of kernel function that supports the capturing of nuances within the data. Below are our implmentation results of the performance metrics of Support Vector Machine (SVM) models trained with different kernel functions: polynomial (SVM-Poly), radial basis function (SVM-RBF), and sigmoid (SVM-Sigmoid). 

One note on our SVM-Poly implementation - it is equivalent to a standard SVM linear kernel, as we have implemented it with `degree=1`.  We found during our evaluation, for reasons unknown to us, that polynomial implementation with degree 1 ran faster than that of the standard linear kernel.  This was simply crafted this way to reduce execution time.

To tune each version of this model, we leveraged a reduced set of principal components, and adjusted class weighting, as having useful votes for a product is a relative rarity across each of the e-commerce platforms.  To boost our recall, we elected to assign weights of 0.2 to class 0 (not useful) and 0.8 to class 1 (useful).

Furthermore, for the tuned model, we adjusted the probability threshold to 0.1 vs. the default 0.5 and class weighting set to better adjust the model for mis-classification of the minority class (as we did for the logistic regression).  The combination of this shift with the class weighting allowed us to achieve a total positive prediction rate in close proximity to the actual true positives. 

### SVM Test Results

```{python tbl-svm-test-results}
#| label: tbl-svm-test-results
#| tbl-cap: Test Scores for Support Vector Machine

## need to divide this into pieces to add figure labels
# SVM Poly
random.seed(123)

spt_vector = svm.SVC(
    kernel='poly',degree=1,class_weight={0:0.2,1:0.8},probability=True,
).fit(X_train_pca,y_train)

y_pred_poly_prob = spt_vector.predict_proba(X_test_pca)[:,1]

y_pred_poly = y_pred_poly_prob > 0.1 #spt_vector.predict(X_test_pca)
test_metrics.loc[len(test_metrics)] = {
    'Model':'SVM-Poly',
    #'Useful Level':"above 0",
    'Accuracy':accuracy_score(y_test,y_pred_poly),
    'F1':f1_score(y_test,y_pred_poly),
    'Precision':precision_score(y_test,y_pred_poly),
    'Recall':recall_score(y_test,y_pred_poly)
}

# SVM RBF
spt_vector_rbf = svm.SVC(
    kernel='rbf',degree=1,class_weight={0:0.2,1:0.8}#,probability=True
).fit(X_train_pca,y_train)

y_pred_rbf = spt_vector_rbf.predict(X_test_pca)
test_metrics.loc[len(test_metrics)] = {
    'Model':'SVM-RBF',
    #'Useful Level':"above 0",
    'Accuracy':accuracy_score(y_test,y_pred_rbf),
    'F1':f1_score(y_test,y_pred_rbf),
    'Precision':precision_score(y_test,y_pred_rbf),
    'Recall':recall_score(y_test,y_pred_rbf)
}

# SVM Sigmoid
spt_vector_sigmoid = svm.SVC(
    kernel='sigmoid',degree=1,class_weight={0:0.2,1:0.8}#,probability=True
).fit(X_train_pca,y_train)

y_pred_sigmoid = spt_vector_sigmoid.predict(X_test_pca)
test_metrics.loc[len(test_metrics)] = {
    'Model':'SVM-Sigmoid',
    #'Useful Level':"above 0",
    'Accuracy':accuracy_score(y_test,y_pred_sigmoid),
    'F1':f1_score(y_test,y_pred_sigmoid),
    'Precision':precision_score(y_test,y_pred_sigmoid),
    'Recall':recall_score(y_test,y_pred_sigmoid)
}

# Display results
# test_metrics_df = pd.DataFrame(test_metrics)
# display(test_metrics_df[7:].style.hide(axis='index'))

display(
    test_metrics[
        test_metrics['Model'].str.contains('SVM')
    ].style.hide(axis='index')
)

```

```{python fig-cm-svm}
#| label: fig-cm-svm
#| fig-cap: Confusion Matrices for Support Vector Machines
#| fig-align: center

fig, axes = plt.subplots(3, 1, figsize=(18, 6))

ConfusionMatrixDisplay(confusion_matrix(y_test,y_pred_poly)).plot(ax=axes[0])
axes[0].set_title('SVM Poly Model')

ConfusionMatrixDisplay(confusion_matrix(y_test, y_pred_rbf)).plot(ax=axes[1])
axes[1].set_title('SVM RBF Model')

ConfusionMatrixDisplay(confusion_matrix(y_test, y_pred_sigmoid)).plot(ax=axes[2])
axes[2].set_title('SVM Sigmoid Model')

plt.tight_layout()
plt.show()
```

```{python UsefulComments-knn}
test_frame['pred_useful'] = y_pred_poly_prob
dat = test_frame[test_frame['is_helpful']==0].sort_values(by='pred_useful',ascending=False)[['site_y','product','product_price','review_header','reviewer_name','review_content','review_star_rating','review_helpful_votes','review_polarity','review_subjectivity','review_length','total_star_rating','prod_subjectivity','pred_useful']].copy().reset_index()

# for i,row in dat.iterrows():
#     print(
#         "Review #{} ({})\n{}\n".format(i+1,row['product'],row['review_content'])
#     )

dat.to_csv('../data/SVMPolyPredUseful.csv')
```

Looking the SVM testing results, we can say that:

1. SVM with a polynomial kernel (set to degree 1, or linear) predicts a total percent of true positives close to the underlying source data (approximately 17%).  

2. SVM with radial basis function kernel appears to under-predict positive cases and fails to meet our F1 threshold.

3. SVM with sigmoid kernel over-predicts false positives and fails to meet our F1 threshold.

SVM Poly (linear, degree 1) appears to achieve reasonable accuracy while hitting an appropriate level for F1 and Recall for our use case.  The presence of false positives gives us something to subjectively examine for its usefulness as a potential customer.

## Model Comparison

We examine the following table to compare and contrast our implemented models on our collected data.

```{python tbl-final-results}
#| label: tbl-final-results
#| tbl-cap: Summary Metrics (all evaluated models)
test_metrics.style.hide(axis='index')
```

The most interesting results, we find, come from the tuned Logistic Regression model and SVM-Poly models. These seem to hit a sweet spot when it comes to F1 and recall scores.  Exceeding certain thresholds (at or around 0.5), seems to have too high a percentage of false positives.  

50% of our oversampled training data held votes as being useful comments, and our regular training data contained samples with approximately 7% being voted as useful.

For our testing data, approximately 17% of the records held votes for being useful.

The Tuned Logistic Regression predicted a total number of positive (true and false positives) of 1606, or 17.99% of the available samples.  This result is very close in proximity to the actual total for true positives within the data.

The SVM Poly model also produced a prediction of approximately 17.5% of the testing data being useful (comparable to the actual value of 17%).

None of the other model formulations or permutations achieved a percentage of total positive prediction rate as in close proximity to the actual underlying data.

The false positives for SVM-Poly and Tuned Logistic Regression are located here:

* [Logistic Regression Prediction Results](https://github.com/pconnell/CSCI-Final-Project/blob/main/data/LogisticRegressionPredUseful.csv)

* [Support Vector Machine Prediction Results](https://github.com/pconnell/CSCI-Final-Project/blob/main/data/SVMPolyPredUseful.csv)

* [K-Nearest Neighbor Prediction Results](https://github.com/pconnell/CSCI-Final-Project/blob/main/data/KNNPredUseful.csv)

* [Multiple Linear Regression Prediction Results](https://github.com/pconnell/CSCI-Final-Project/blob/main/data/MLRPredUseful.csv)

* For each of the models, the files are filtered to solely contain false positive reviews (those for which the model predicted the review is useful, but had no votes in favor of it in the source data).

Amongst the ranking of outputs from MLR, Logistic Regression, and SVM, we see some common threads.

* Each recommended the same top 3 review comments for the following products:

    * Mario Kart 8 from Amazon.
    
    * Dyson Ball Vacuum from Target.
    
    * HP Deskjet 2755e Printer from Amazon.


```{python tbl-met-comp}
#| label: tbl-met-comp
#| tbl-cap: Comparison of Metrics, top 30 Reviews for 3 models.

lg_pred = pd.read_csv('../data/LogisticRegressionPredUseful.csv')
mlr_pred = pd.read_csv('../data/MLRPredUseful.csv')
svm_pred = pd.read_csv('../data/SVMPolyPredUseful.csv')
resLG = pd.DataFrame(lg_pred.head(30).describe())

resLG = resLG[resLG.index.isin(['mean','std'])]
resLG['model'] = "Logistic Regression (Tuned)"

resMLR = pd.DataFrame(mlr_pred.head(30).dropna(axis=1).describe())

resMLR = resMLR[resMLR.index.isin(['mean','std'])]
resMLR['model'] = "MLR"

resSVM = pd.DataFrame(
    svm_pred.head(30).describe()
)

resSVM = resSVM[resSVM.index.isin(['mean','std'])]
resSVM['model'] = "SVM-Poly (Tuned)"

        # 'review_subjectivity', 'review_polarity',
        # 'review_length','prod_subjectivity','total_star_rating', 'site', 'review_helpful_votes'

summary = pd.concat([resLG,resMLR,resSVM])
display(
    summary[[
        'review_subjectivity', 'review_polarity',
        'review_length','prod_subjectivity','total_star_rating'
    ]]
)

```

* Examining some metrics from the top 30 recommended "useful" reviews - 

    * Logistic Regression and SVM had similar means and standard deviations for review star rating, review subjectivity, and review polarity.  Each seemed to prefer slightly positive reviews (as follows from our EDA), and an even split on the subjectivity of the text (not overly precise, not overly vague).

    * Each model seemed to hold a preference for longer reviews, and for product descriptions that we assess may be considered "mixed" products (part search, part experience).  Each model also held a preference for higher total star ratings for the product.

    * The MLR holds a bias toward higher star ratings (4.1) in its predictions.  Similarly, it had a greater bias toward positivity in the review  similar subjectivity preference as held within Logisitic Regression and SVM.

    * Generally the near "neutrality" with regards to polarity, subjectivity, and star rating for logistic regression and SVM could be useful to prospective customers.  Allowing users to filter results based off of these predicted classifications could bring balance to other reviews presented when sorted in descending order by number of useful votes.  The neutrality aspect can give the customer insight into unknown positive or negative reviews and shed light on useful information as a potential customer.

    * The presence of common reviews within the top 30 suggests that each of these models could hold a degree of validity.  The interpretation and assessment, however, is subjective.  Performing a further study with participants to evaluate the prediction of useful comments would support determining the validity of these models and their effectiveness.

<!--
Each of these models had similar performance in terms of accuracy and precision. A key consideration for us is within the realm of recall in that false positives are potentially beneficial to the generalization of this model to identify reviews that are useful, but currently possess no helpful votes.  None of the models delivered any false positives, but having high recall may support identification of new, useful comments.

The top 2 performing models were our Support Vector Machine and Logistic Regression implementations.  Between the two, SVM had higher recall, which is preferable in our use case.  That being said, on every metric between the two models, there was near equivalent performance.

With our preferences toward higher recall, the implementation of the SVM-Sigmoid and SVM-RBF models delivered best on our objectives, identifying the highest volume of true positives, minimizing false negatives, and providing a limited number of true positives that could identify comments with no votes that are useful to customers. 

From a stakeholder standpoint, these two models can both be beneficial, whether looking from the standpoint of the customer or the e-commerce platform.

The RBF model, with more exploration and examination, could be very beneficial to e-commerce platforms.  If the model could be modified and updated to identify comments that are closer in proximity to promotional comments (which potentially come at a cost to these platforms), it may allow them to present comments similar in quality to a paid promotional review without the platform having to pay for it.

The Sigmoid model, with additional training and tuning, could be of greater benefit to customers.  This model is less inclined to capture promomtional feedback comments and provide potentially useful feedback absent other outside influence.  At a subjective level, not all of the content contained in these classified reviews are useful, though many are. <!-- any additional writeup comments here-->